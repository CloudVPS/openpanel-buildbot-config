# -*- python -*-
# ex: set syntax=python:

import time 
from buildbot import manhole
from buildbot.config import BuilderConfig
from buildbot.buildslave import BuildSlave
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import Property, Properties, WithProperties
from buildbot.steps.source import Mercurial
from buildbot.steps.shell import ShellCommand, SetProperty
from buildbot.process.buildstep import LoggingBuildStep, BuildStep, RemoteShellCommand
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers import timed
from buildbot.changes.filter import ChangeFilter
from buildbot.status import html
from buildbot.status.web import authz
from buildbot.process import buildstep, factory, properties
from buildbot.steps.master import MasterShellCommand
from buildbot.status import results 
from buildbot.steps.transfer import FileUpload, DirectoryUpload
from buildbot.status.html import WebStatus
from buildbot.status.web.authz import Authz
from buildbot.status.web.auth import BasicAuth
from buildbot.interfaces import IProperties


import commands
import os

repositories = {'dev': '/srv/repository', 'stable': '/srv/repository-stable'}

# This checks/creates an empty Debian repo based on settings in /srv/repository/conf
# everytime buildbot rebuilds it's config. 
# If the repo is not there, the build will fail. 
# However, if this command runs every build, some build somewhere will fail due to
# lockfiles.

for repo in repositories:
    commands.getoutput('reprepro -b %s export' % repo)




# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

# Set global and default Build Properties here.
c['properties'] = {
    'tag' : 'tip',
}

c['builders'] = []


####### BUILDSLAVES
c['slaves'] = [
                BuildSlave("debian6-amd64", "pass", max_builds=1), 
                BuildSlave("centos5-slave", "pass", max_builds=1), 
                BuildSlave("postprocess-slave", "pass", max_builds=1),  # -- See comment at
                                                                        #    slave definition.
                ]

# Port slaves will connect to:
c['slavePortnum'] = 9989

# Set global env variables to be used in buildsteps here.
# (Remember to use env=env when using shellcommands!)
env={'DEBFULLNAME': 'OpenPanel packager', 'DEBEMAIL': 'packages@openpanel.com'}

# This is a dictionary of distribution specific attributes needed to config,
# make, make install using distro specific tools and settings. 
# Fragmentation is a joy!
distrodict = {
            "debian": {
                "pkg": "deb",
                "version": {
                    "5": "lenny",
                    "6": "squeeze",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "ubuntu": {
                "pkg": "deb",
                "version": {
                    "10.04": "lucid",
                    "11.04": "natty",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "centos": {
                "pkg": "rpm",
                "version": {
                    "5": "centos5",
                    },
                "architectures": [
                        "x86_64", 
                        "i386",
                    ],
                },
            }
    
# Create a list of components, 
# with lists of supported distros (pkging methods, really). 
# Each component corresponds with an hg repo on hg.openpanel.com.
# The order in which these components are listed here is the order in which
# a Builder will build them. 
all_components=[
        ['grace', ["deb", "rpm"]],
        ['opencore', ["deb", ]],
        ['opencore-ssl', ["deb", ]],
        ['opencli', ["deb", ]],
        ['authd', ["deb"]],
        ['openpanel-gui', ["deb"]],
        ['validatepem', ["deb"]],
        ['vacationdrop', ["deb"]],
        ['swupd', ["deb"]],
        ['logax', ["deb"]],
        ['limadaemon', ["deb"]],
        ['coreval', ["deb"]],
        ['coreunreg', ["deb"]],
        ['User.module', ["deb"]],
        ['Stub.module', ["deb"]],
        ['SpamAssassin.module', ["deb"]],
        ['SoftwareUpdate.module', ["deb"]],
        ['SSH.module', ["deb"]],
        ['Pptpd.module', ["deb"]],
        ['PostfixCourier.module', ["deb"]],
        ['Networking.module', ["deb"]],
        ['MySQL.module', ["deb"]],
        ['Keepalived.module', ["deb"]],
        ['IPTables.module', ["deb"]],
        ['FTP.module', ["deb"]],
        ['Domain.module', ["deb"]],
        ['DNSDomain.module', ["deb"]],
        ['ApacheForward.module', ["deb"]],
        ['Apache2.module', ["deb"]],
        ['Amavis.module', ["deb"]],
        ['AWStats.module', ["deb"]],
        ['openapp/openpanel-openapp-pureftpd-auth', ["deb"]],
        ['openapp/openpanel-openapp-mysql-artwork', ["deb"]],
        ['openapp/openpanel-openapp-mod-wordpress', ["deb"]],
        ['openapp/openpanel-openapp-mod-user', ["deb"]],
        ['openapp/openpanel-openapp-mod-smtp', ["deb"]],
        ['openapp/openpanel-openapp-mod-ruby', ["deb"]],
        ['openapp/openpanel-openapp-mod-mysql', ["deb"]],
        ['openapp/openpanel-openapp-mod-joomla', ["deb"]],
        ['openapp/openpanel-openapp-mod-drupal', ["deb"]],
        ['openapp/openpanel-openapp-mod-cron-apt', ["deb"]],
        ['openapp/openpanel-openapp-mod-backup', ["deb"]],
        ['openapp/openpanel-openapp-mod-apache2', ["deb"]],
        ['openapp/openpanel-openapp-gui', ["deb"]],
        ['openapp/openpanel-openapp-call', ["deb"]],
        ['openapp/openapp-xtrabackup', ["deb"]],
        ['openapp/openapp-wordpress-installer', ["deb"]],
        ['openapp/openapp-tuning', ["deb"]],
        ['openapp/openapp-tomcat', ["deb"]],
        ['openapp/openapp-symfony', ["deb"]],
        ['openapp/openapp-ruby', ["deb"]],
        ['openapp/openapp-phpmyadmin-installer', ["deb"]],
        ['openapp/openapp-mysql', ["deb"]],
        ['openapp/openapp-lamp', ["deb"]],
        ['openapp/openapp-joomla-installer', ["deb"]],
        ['openapp/openapp-drupal', ["deb"]],
        ['openapp/openapp-backup', ["deb"]],
        ['openapp/openapp-awstats', ["deb"]],
    ]

def MercurialXLS(f, hgrepo):
    '''
    Internal mercurial function didn't do what needed to be done (use tags). This is
    more dirty, yet does. 

    It uses the build property 'tag', that has to be
    set globally and is overridden via the webinterface as a Property

    '''

    # Define BuildSteps:

    # Add steps to factory:
    f.addSteps([
        SetProperty(command='echo build', property="hgworkdir"),
        SetProperty(command='echo %s' % hgrepo, property="hgrepo"),
        ShellCommand(command=['/bin/bash', '-c', WithProperties('rm -rf ../%(hgworkdir)s'),]),
        ShellCommand(command=['/bin/bash', '-c', WithProperties('hg clone %(hgrepo)s ../%(hgworkdir)s -r %(tag)s'),]),
    ])
    return f
    
def PostProcess(distro):
    
    '''
        This factory is used for buildsteps (mostly on the master) that publish
        the build results to where ever you need. 

        The idea of doing this in a seperate factory instead of the generic one
        is that it should allow for more flexibility. If not, then this can be
        dropped and added to the main factory.

        In it's current form, it's only added value is that doing it this way,
        we make use of buildbots queueing. Thus there shouldn't be more than 1
        rsync at a time.
    
        Currently there are only steps for Debian/Ubuntu as it includes the
        publishing of the .deb files to the public repository.
    
    '''

    f = BuildFactory()
    f.addSteps([
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/synctobob.py',], env=env),
    ])
    return f
    
def make_component_factory(component, distro, distroversion, arch, tag):
    """
        Builds and publishes a single component (project).
    """

    f = BuildFactory()
    make_factory(f, distro, distroversion, arch, component, tag)
        

    # Trigger the rsync to bob in a seperate buildstep so it gets queued
    # nicely. This way, no 2 rsyncs can be done at the same time.
    f.addSteps([
         MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'PostProcess', '-p', WithProperties('{"distro": "%(distro)s", "distroversion": "%(distroversion)s", "arch": "%(arch)s"}')]),
     ])

    return f

def make_factory(f, distro, distroversion, arch, component, tag):
    '''
        This function does the brunt of the work. It is to be called after the
        logic has been determined what component to build. 

        In other words this makes: 
            one component
            for one distro
            for one distroversion
            on one arch
            of one hg tag
    '''

    def DoRelease(props):
        """
            When doing a release, some variables need to be set differently.

            Interprets the property 'tag' and defines the new version scheme
            (newver) based on that. 

            The versioning is dependent on whether this is a release or a
            nightly build. We use the BuildProperty 'tag' to determine if
            something is a release or a nightly. 

            Buildbot cannot/will not allow filtering on BuildProperties as it
            reasons that those Properties do not exist prior to building. In
            our case, this is not true. 
        """

        if props.getProperty('release') == 'true':
            newver = "%s+%s" % (props.getProperty('tipmost'), props.getProperty('lsbdistcodename'))
            newver = props.setProperty('newver', newver, "NewVer")
            debrepo = props.setProperty('debrepo', '/srv/repository-stable', "setDebRepo")
            deb_aptrepo = props.setProperty('deb_aptrepo', 'http://141.138.195.13/stable', "DoRelease")
            incoming_dir = props.setProperty('incoming_dir', '/tmp/incoming-stable', "DoRelease")
        else:
            newver = "%s-%s-%s.1+%s" % (props.getProperty('tipmost'), props.getProperty('rev'), props.getProperty('date'),props.getProperty('lsbdistcodename'))
            newver = props.setProperty('newver', newver, "NewVer")
            debrepo = props.setProperty('debrepo', '/srv/repository', "setDebRepo")
            deb_aptrepo = props.setProperty('deb_aptrepo', 'http://141.138.195.13/dev', "DoRelease")
            incoming_dir = props.setProperty('incoming_dir', '/tmp/incoming', "DoRelease")
        if props.getProperty('distro')  == 'ubuntu':
            dist_mirror = props.setProperty("dist_mirror", "http://ftp.ubuntu.com/ubuntu", "DoRelease")
            dist_components = props.setProperty("dist_components", "main restricted universe multiverse", "DoRelease")
        elif props.getProperty('distro') == 'debian':
            dist_mirror = props.setProperty("dist_mirror", "http://ftp.nl.debian.org/debian", "DoRelease")
            dist_components = props.setProperty("dist_components", "main contrib non-free", "DoRelease")
        return props['newver']

    lsbdistcodename=distrodict[distro]["version"][distroversion]

    # Look up in a dictionary if we're going to build RPMs or DEBs
    pkg_method = distrodict[distro]["pkg"]

    hgrepo = "http://hg.openpanel.com/%s/" % component

    MercurialXLS(f, hgrepo)

    
    # BUILDSTEPS:
    # Copying local variables to Properties. 
    set_date = SetProperty(command=['/bin/bash', '-c', "date +%Y%m%d-%H%M%S"], property="date")
    set_lsbdistcodename = SetProperty(command=['echo', "%s" % lsbdistcodename, ], property="lsbdistcodename")
    set_arch = SetProperty(command=['echo', "%s" % arch, ], property="arch")
    set_distro = SetProperty(command=['echo', "%s" % distro, ], property="distro")
    set_distroversion = SetProperty(command=['echo', "%s" % distroversion, ], property="distroversion")
    set_component = SetProperty(command=['echo', "%s" % component, ], property="component")
    set_ex = SetProperty(command=['echo', "1" , ], property="ex")

    # REVISION
    rev = SetProperty(command='hg id -n | /bin/sed -e "s/+$//"', property="rev")

    pre_tipmost = SetProperty(command='/bin/bash -c \"hg tags | cut -f 1 -d \' \' | head -n 2 | tail -n 1\"', property="pre_tipmost") 

    tipmost = SetProperty(command=WithProperties('/bin/bash -c \"if [[ %(pre_tipmost)s == \'tip\' ]] ; then echo \'0.0.0\' ; else echo %(pre_tipmost)s;  fi\"'),  property="tipmost") 


    # --- RPM SPECIFIC

    # We need the .spec name to feed to the mock --buildsrpm later on...
    set_spec_name = SetProperty(command='/bin/bash -c "ls rpm/*.spec | head -n 1"',  property="spec_name")


    #Bah.
    copy_folder = ShellCommand(command=['cp', 
                                        '-a', 
                                        '.', 
                                        WithProperties("../%(rpm_name)s-%(rpm_version)s"),])

    # This assumes that there is only ONE spec file!
    set_rpm_name = SetProperty(command='/bin/bash -c "grep ^Name: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_name")

    set_rpm_version = SetProperty(command='/bin/bash -c "grep ^Version: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_version")

    set_rpm_repopath = SetProperty(command=['echo', WithProperties("%(debrepo)s/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/"),], property="rpm_repopath")

    rpm_createrepo = ShellCommand(command=['/bin/bash', '-c', WithProperties('cd %(rpm_repopath)s && createrepo .'),], env=env)

    # Going to upload to a tmp folder:
    rpm_upload_to_master = DirectoryUpload(slavesrc=WithProperties("%(rpm_repopath)s/"), masterdest=WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'))

    # Feeding tmp folder to rpmsign script:
    rpm_master_sign = MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/rpmsign.py',
                        WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                )
            
    # Remove the temporary incoming folder:
    rpm_master_remove = MasterShellCommand(command=['rm', '-rf',
                        WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                )

    # Officially decided that we will be using bzip2, not gzip. Any .spec
    # referring to gz files should fail.
    rpm_tbz = ShellCommand(command=['tar', 
                                'jcf',
                                WithProperties('../%(rpm_name)s-%(rpm_version)s.tar.bz2'), 
                                WithProperties('../%(rpm_name)s-%(rpm_version)s'), 
                                ])

    # Have mock build a SRPM
    rpm_mock_buildsrpm = ShellCommand(command=['mock', 
                                '--buildsrpm',
                                WithProperties('--spec=%(spec_name)s'),
                                WithProperties('--sources=%(workdir)s/'),
                                WithProperties('--resultdir=%(workdir)s/'),
                                WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                ])

    # Fetch the name of the srpm:
    get_src_rpm_name = SetProperty(command='/bin/bash -c "ls ../ | grep .src.rpm"',  property="src_rpm")

    # Feed SRPM to build RPM
    rpm_mock_rebuild = ShellCommand(command=['mock', 
                                '--rebuild',
                                WithProperties('../%(src_rpm)s'), 
                                WithProperties('--resultdir=%(debrepo)s/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/'),
                                '-r',
                                WithProperties('%(distro)s-%(distroversion)s-%(arch)s'),
                                ], env=env)

    rpm_master_mkdir = MasterShellCommand(command=["mkdir", 
                                "-p", 
                                WithProperties('%(rpm_repopath)s'),
                                ],
                                )
    # Clean up srpm:
    clean_src_rpm = ShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('rm -rf ../%(src_rpm)s'),])

            
    # Clean up the mock env
    rpm_mock_clean = ShellCommand(command=['mock', 
                                '--clean',
                                WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                ])


    # Createrepo on master
    rpm_master_createrepo = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('createrepo %(rpm_repopath)s'),
                                ], env=env)

    rpm_master_copy = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('cp /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm %(rpm_repopath)s'),],env=env)

    rpm_master_clean = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('rm -rf /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm '),],env=env)
    # --- END OF RPM SPECIFIC STEPS.

    # --- START DEB SPECIFIC STEPS

    # Get the name of the source package
    src_name = SetProperty(command="/bin/bash -c \" if [[ -e debian/control ]] ; then cat debian/control | grep ^Source: | sed -e 's/^Source: //'; else exit 1; fi\"", 
                            property="src_name", 
                            env=env,
                            )

    # Now that we have the version nr, we should be 
    debchange = ShellCommand(command=['debchange', 
                                '--force-bad-version', 
                                '--newversion', 
                                WithProperties('%(newver)s'), 
                                'autogenerated', 
                                '--force-distribution', 
                                '--distribution', 
                                WithProperties('%(lsbdistcodename)s')],
                                )


    # Now that we have a .dsc, we can build a source package:
    dpkg_buildpackage = ShellCommand(command=['dpkg-buildpackage', 
                                    '-us', 
                                    '-uc', 
                                    '-d', 
                                    '-S', 
                                    '-sa', 
                                    '-i', 
                                    '-I',
                                    ])

    deb_mkrepo = MasterShellCommand(command=[
                    '/bin/bash', '-c', WithProperties('cd /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s && dpkg-scanpackages -m . /dev/null | gzip -9c >Packages.gz'),
            ])
    # Now that we have a source package, we can build a binary package:
    #pbuilder = ShellCommand(command=['/bin/bash', '-c', WithProperties('pbuilder build --aptcache "" --hookdir /srv/hook --basetgz /var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz --buildresult /var/cache/pbuilder/result/%(src_name)s_%(newver)s/ ../%(src_name)s_%(newver)s.dsc'),])
    #pbuilder = ShellCommand(command=['/bin/bash', '-c', WithProperties('pbuilder build --aptcache "" --hookdir /srv/hook --basetgz /var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz --buildresult /var/cache/pbuilder/result/%(src_name)s_%(newver)s/ ../%(src_name)s_%(newver)s.dsc'),])
    #pbuilder = ShellCommand(command=['/bin/bash', '-c', WithProperties('pbuilder --build --distribution %(lsbdistcodename)s --override-config --othermirror "deb %(deb_aptrepo)s %(lsbdistcodename)s main" --aptcache "" --hookdir /srv/hook --basetgz /var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz --buildresult /var/cache/pbuilder/result/%(src_name)s_%(newver)s/ ../%(src_name)s_%(newver)s.dsc'),])

    pbuilder = ShellCommand(command=['/bin/bash', '-c', WithProperties('pbuilder --build --distribution %(lsbdistcodename)s --override-config --mirror "%(dist_mirror)s" --components "%(dist_components)s" --othermirror "deb %(deb_aptrepo)s %(lsbdistcodename)s main" --aptcache "" --hookdir /srv/hook --basetgz /var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz --buildresult /var/cache/pbuilder/result/%(src_name)s_%(newver)s/ ../%(src_name)s_%(newver)s.dsc'),])
    
    # Upload all components to one folder that will get pushed to
    # the repository in one go. 
    deb_upload_from_slave = DirectoryUpload(
            slavesrc=WithProperties(
                "/var/cache/pbuilder/result/%(src_name)s_%(newver)s"), 
                masterdest=WithProperties("/tmp/incoming/%(buildername)s"))
    # Add all files in incoming folder to repository:
    '''
    reprepro = MasterShellCommand(command=['reprepro', 
                        '-V', 
                        '--waitforlock', 
                        '12', 
                        '-b', 
                        WithProperties("%(debrepo)s"),
                        'processincoming',
                        WithProperties("%(distro)s_%(distroversion)s_%(arch)s"),
                        ],
                )
    '''
    
    # Use a script to GPG sign the packages:
    deb_master_sign = MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/sign.sh', WithProperties('/tmp/incoming/%(buildername)s'),], env=env)

    # Place packages in the correct repository:
    reprepro = MasterShellCommand(command=['/bin/bash', '-c', WithProperties('reprepro -V -b %(debrepo)s  includedeb %(lsbdistcodename)s /tmp/incoming/%(buildername)s/*.deb ' ),], haltOnFailure=False,flunkOnFailure=False,warnOnFailure=True) # Sometimes an identical package already exists. 

    # --- END DEBIAN SPECIFIC

    version_id = ShellCommand(command=['/bin/bash', '-c', WithProperties('echo %(tipmost)s > version.id')])

    # buildbot master (twistd) runs with a strict (unconfigurable) umask.
    # I have changed the twistd source file to set umask to 022. Therefor,
    # these steps are no longer strictly needed. However: better safe than
    # sorry.
    repo_permission_fix = MasterShellCommand(command=[
                    '/bin/bash', '-c', WithProperties(' find %(debrepo)s -type d -perm 700 -exec chmod 755 {} \;') ,
        ])
    repo_permission_fix_files = MasterShellCommand(command=[
                    '/bin/bash', '-c', WithProperties(' find %(debrepo)s -type f -perm 600 -exec chmod 644 {} \;'),
        ])


    # Generic steps:
    f.addSteps([
        set_date,
        set_lsbdistcodename,
        set_arch,
        set_distro,
        set_distroversion,
        set_component,
        MasterShellCommand(command=["mkdir", "-p",  WithProperties('/tmp/incoming/%(buildername)s'),]),
        MasterShellCommand(command=["mkdir", "-p",  WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),]),
        # Do a clone of hgrepo:


        #set_debrepo,
        set_ex,
        pre_tipmost,
        tipmost,
        rev,
        ShellCommand(command=['/bin/bash', '-c', "echo", WithProperties('%(newver)s', newver=DoRelease),]),
        ShellCommand(command=['/bin/bash', '-c', "echo", WithProperties('%(newver)s'),]),
        SetProperty(command=['/bin/bash', '-c', WithProperties('echo %(newver)s | sed -e \"s/\ //g\"'),  ], property="newver"), # Not sure if this is still needed. FIXME
        ])

    # Packaging method dependent steps:
    if pkg_method is "deb":
        f.addSteps([
            src_name,
            
            # Clean up previous results dir if exists, just to make sure. 
            ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
            # Create a results folder to place the .debs in (before passing it onto
            # reprepro)
            ShellCommand(command=['mkdir', '-p', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
    
            debchange,
            version_id,
            dpkg_buildpackage, 
            repo_permission_fix,
            repo_permission_fix_files,
            # Create a tmp apt repo right here on the spot:
            # This needs to be done here or else pbuilder will bork on not
            # finding Packages.gz on this location.
            deb_mkrepo,
            pbuilder,
            #ShellCommand(command=['/bin/bash', '-c', 'debuild -S', ]),
            
            deb_upload_from_slave, 
            # Clean up after our selves:
            ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),

            deb_mkrepo,

            # Debug output for me:
            ShellCommand(command=['echo', 'DEBUG:', WithProperties('%(ex)s, %(src_name)s %(component)s %(date)s %(lsbdistcodename)s %(arch)s %(tipmost)s '),]),
        ])

    # steps for building RPMs:
    if pkg_method is "rpm":
        f.addSteps([
            set_spec_name,
            set_rpm_name,
            set_rpm_version,
            copy_folder,
            set_rpm_repopath,
            rpm_createrepo,
            rpm_master_mkdir,
            rpm_tbz, 
            rpm_mock_buildsrpm,
            get_src_rpm_name,
            rpm_mock_rebuild,
            clean_src_rpm, 
            rpm_upload_to_master,
            rpm_master_sign,
            rpm_mock_clean,
        ])

    # Postprocessing RPM
    if pkg_method is "rpm":
        '''
            Steps to run after all rpm components have finished
        '''
        f.addSteps([
                rpm_master_copy,
                rpm_master_clean,
                rpm_master_createrepo,
        ])

    if pkg_method is "deb":
        '''
            Steps to run after all Debian/Ubuntu components have finished:
        '''
        f.addSteps([
            deb_master_sign, 

            # Place packages in correct repo:
            reprepro,

            # Clean up:
            MasterShellCommand(command=['/bin/bash', '-c', WithProperties('rm -rf  /tmp/incoming/%(buildername)s/* ')], alwaysRun=True),

        ])
    

    # Now that we have all the steps in a factory, we can hand the factory back
    # to the Builder:
    return f
    # --- END OF make_factory()

# A special builder that does postprocessing stuff
# (runs reprepro and syncs to bob.openpanel.com)
c['builders'].append(
    BuilderConfig(name="PostProcess",
    slavenames='postprocess-slave',  # <-- required parameter, even if no slave buildsteps.
    factory=PostProcess("debian")))


# This creates a builder per component, per distro/distroversion/distroarch:
for dist in distrodict:
    components = []
    # Assign slaves and a list of components based on distro:
    if dist == "debian":
        slavenames = ['debian6-amd64']
        components = [c[0] for c in all_components if "deb" in c[1]]
    elif dist == "ubuntu":
        slavenames = ['debian6-amd64']
        components = [c[0] for c in all_components if "deb" in c[1]]
    elif dist == "centos":
        slavenames = ['centos5-slave']
        components = [c[0] for c in all_components if "rpm" in c[1]]

    # Differentiate the builders on component, distro, distro version and architecture:
    for component in components:
        for version in distrodict[dist]['version']:
            for arch in distrodict[dist]['architectures']:
                    name = "%s_%s_%s_%s" % (component, dist , version , arch)
                    c['builders'].append(
                        BuilderConfig(name=name,
                        slavenames=slavenames,
                        factory=make_component_factory(component, dist, version, arch, 'tip')))  # <-- change 'tip' if you need a different tag to be built.



# -- SCHEDULERS
# These define when a builder is called.
# Docs: http://buildbot.net/buildbot/docs/0.8.5/manual/cfg-schedulers.html

# Start out empty:
c['schedulers'] = []

# Since we have all builders defined, we can add schedules to them.
for builder in c['builders']:
    # This enables calling builders remotely:
    # (specifically 'change_filter' does that)
    name = builder.name
    c['schedulers'].append(
        SingleBranchScheduler(
            name = name,
            change_filter = ChangeFilter(project=name),
            treeStableTimer = 1, 
            builderNames = [name],
        ),)
    # Scheduled (time based) builds:
    c['schedulers'].append(
        timed.Nightly(
            name = 'nightly_%s' % name,
            builderNames=[name],
            hour=22,
            minute=30,
            branch="",
        ),
    ),




# Users that can do stuff:
users = [('bob', 'secret-pass'), ('jill', 'super-pass')]

# What can be done by those users:
authz = Authz(auth=BasicAuth(users),
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True,
    #PRODforceBuild = 'auth',
    forceAllBuilds = True,
    pingBuilder = False,
    stopBuild = True,
    stopAllBuilds = True,
    cancelPendingBuild = True,
)

####### STATUS TARGETS

# Official comments:
# ----
# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.
# ----
# Doc: http://buildbot.net/buildbot/docs/0.8.5/manual/cfg-statustargets.html

c['status'] = []

# -- This helps to enable buildbot to allow remotely triggered builds over
#    http:
c['status'].append(html.WebStatus(http_port=8010, authz=authz, 
        change_hook_dialects={
                'openpanel_hook': True,
            }
        ))

# On what port to listen for slaves:
from buildbot.changes import pb
c['changes'] = pb.PBChangeSource(port=9989)


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "OpenPanel"
c['titleURL'] = "http://openpanel.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

# Details on these settings can be found here:
#   --> http://buildbot.net/buildbot/docs/0.8.5/manual/cfg-global.html
#
c['logCompressionLimit'] = 16384
c['logCompressionMethod'] = 'gz'
c['logMaxSize'] = 1024*1024 # 1M
c['logMaxTailSize'] = 32768
c['changeHorizon'] = 200
c['buildHorizon'] = 100
c['eventHorizon'] = 50
c['logHorizon'] = 40
c['buildCacheSize'] = 15

