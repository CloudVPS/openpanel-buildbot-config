# -*- python -*-
# ex: set syntax=python:

import time 
from buildbot import manhole
from buildbot.config import BuilderConfig
from buildbot.buildslave import BuildSlave
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import Property, Properties, WithProperties
from buildbot.steps.source import Mercurial
from buildbot.steps.shell import ShellCommand, SetProperty
from buildbot.process.buildstep import LoggingBuildStep, BuildStep, RemoteShellCommand
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers import timed
from buildbot.changes.filter import ChangeFilter
from buildbot.status import html
from buildbot.status.web import authz
from buildbot.process import buildstep, factory, properties
from buildbot.steps.master import MasterShellCommand
from buildbot.status import results 
from buildbot.steps.transfer import FileUpload, DirectoryUpload
from buildbot.status.html import WebStatus
from buildbot.status.web.authz import Authz
from buildbot.status.web.auth import BasicAuth


import commands
import os
debrepo = '/srv/repository'

# This checks/creates an empty Debian repo based on settings in /srv/repository/conf
# everytime buildbot rebuilds it's config. 
# If the repo is not there, the build will fail. 
# However, if this command runs every build, the build will fail due to
# lockfiles.
commands.getoutput('reprepro -b /srv/repository export')


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['builders'] = []


####### BUILDSLAVES
c['slaves'] = [
                BuildSlave("debian6-amd64", "pass", max_builds=1), 
                BuildSlave("centos5-slave", "pass", max_builds=1), 
                BuildSlave("postprocess-slave", "pass", max_builds=1),  # -- See comment at
                                                                        #    slave definition.
                ]

# Port slaves will connect to:
c['slavePortnum'] = 9989

# Set global env variables to be used in buildsteps here.
# (Remember to use env=env when using shellcommands!)
env={'DEBFULLNAME': 'OpenPanel packager', 'DEBEMAIL': 'packages@openpanel.com'}



# This is a dictionary of distribution specific attributes needed to config,
# make, make install using distro specific tools and settings. 
# Fragmentation is a joy!
distrodict = {
            "debian": {
                "pkg": "deb",
                "version": {
                    "5": "lenny",
                    "6": "squeeze",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "ubuntu": {
                "pkg": "deb",
                "version": {
                    "10.04": "lucid",
                    "11.04": "natty",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "centos": {
                "pkg": "rpm",
                "version": {
                    "5": "centos5",
                    },
                "architectures": [
                        "x86_64", 
                        "i386",
                    ],
                },
            }
    
def TestFactory(distro):
    '''
        This factory is only here for testing purposes while mucking about with
buildbot without disturbing other code or builds.
    '''

    f = BuildFactory()
    '''
    component = "grace"
    hgrepo = "http://hg.openpanel.com/%s/" % component

    MercurialXLS(f, hgrepo, "tip")
    '''

    date = time.strftime("%Y%m%d-%H%M%S")
    tipmost = "mytipmost"
    f.addSteps([
        SetProperty(command=['echo', 'foo' ], property="foo"),
        SetProperty(command=['echo', '%s-%s' % (tipmost,date), WithProperties('-%(foo)s'),  ], property="newver"),
        SetProperty(command=['/bin/bash', '-c', WithProperties('echo %(newver)s | sed -e \"s/\ //g\"'),  ], property="newver"),
        SetProperty(command=['/bin/bash', '-c', 'echo', '%s-%s' % (tipmost,date),  WithProperties('%s-%s+%s.%s+%s', 'tipmost', 'rev','date', 'ex', 'lsbdistcodename'), ], property="newver"),
        #MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/synctobob.py',], env=env),
    ])


    return f
    


def PostProcess(distro):
    
    '''
        This factory is used for buildsteps (mostly on the master) that publish
        the build results to where ever you need. 

        The idea of doing this in a seperate factory instead of the generic one
        is that it should allow for more flexibility. If not, then this can be
        dropped and added to the main factory.

        In it's current form, it's only added value is that doing it this way,
        we make use of buildbots queueing. Thus there shouldn't be more than 1
        rsync at a time.
    
        Currently there are only steps for Debian/Ubuntu as it includes the
        publishing of the .deb files to the public repository.
    
    '''

    f = BuildFactory()
    '''
    component = "grace"
    hgrepo = "http://hg.openpanel.com/%s/" % component

    MercurialXLS(f, hgrepo, "tip")
    '''

    #date = time.strftime("%Y%m%d-%H%M%S")
    #tipmost = "mytipmost"
    f.addSteps([
        #SetProperty(command=['echo', 'foo' ], property="foo"),
        #SetProperty(command=['echo', '%s-%s' % (tipmost,date), WithProperties('-%(foo)s'),  ], property="newver"),
        #SetProperty(command=['/bin/bash', '-c', WithProperties('echo %(newver)s | sed -e \"s/\ //g\"'),  ], property="newver"),
        #SetProperty(command=['/bin/bash', '-c', 'echo', '%s-%s' % (tipmost,date),  WithProperties('%s-%s+%s.%s+%s', 'tipmost', 'rev','date', 'ex', 'lsbdistcodename'), ], property="newver"),
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/synctobob.py',], env=env),
    ])


    return f
    

def MercurialXLS(f, hgrepo, tag):
    '''
        Internal mercurial function didn't do what needed to be done (use tags). This is
        more dirty, yet does. 
    '''

    # Define BuildSteps:

    set_hgworkdir = SetProperty(command='echo build', property="hgworkdir")
    set_hgrepo = SetProperty(command='echo %s' % hgrepo, property="hgrepo")
    set_hgtag = SetProperty(command='echo %s' % tag, property="hgtag")
    hgclean = ShellCommand(command=['/bin/bash', '-c', WithProperties('rm -rf ../%(hgworkdir)s'),])
    hgclone = ShellCommand(command=['/bin/bash', '-c', WithProperties('hg clone %(hgrepo)s ../%(hgworkdir)s -r %(hgtag)s'),])

    # Add steps to factory:
    f.addSteps([
        set_hgworkdir,
        set_hgrepo,
        set_hgtag,
        hgclean,
        hgclone,
    ])
    return f

def ReleaseFactory(component, distro, distroversion, arch, hgtag):
    '''
        Create buildfactory 

        Create a factory that builds a specific version of a component

        ReleaseFactory('grace', 'debian', '6', 'amd64', '9340shjdofad')

        Decide if this is going to be a 'release', or a nightly.

        Do a checkout
        Do all the buildsteps 
        Upload

    '''

    lsbdistcodename=distrodict[distro]["version"][distroversion]
    buildername = "%s_%s_%s_%s" % (component, distro, distroversion, arch)


    f = BuildFactory()
    f.addSteps([
        MasterShellCommand(command=["mkdir", "-p", 
            WithProperties('/tmp/incoming/%(buildername)s'),]),
    ])

    # Buildsteps
    # Publish
    return f


def XLSsteps(f, component):
        # Start with clean Properties. This makes for less muddy waters when
        # debugging a failed build.
        props = [
                    "hgrepo",
                    "rev",
                    "set_spec_name",
                    "set_rpm_name",
                    "set_rpm_repopath",
                    "get_src_rpm_name",
                    "tipmost",
                    "src_name",
                    "ex",
                    "newver",
                ]
        for prop in props:
            f.addSteps([SetProperty(command='echo ""', property=prop)])

        hgrepo = "http://hg.openpanel.com/%s/" % component
        # Do a mercurial clone:
        MercurialXLS(f, hgrepo, "tip")
        return f



def make_factory(distro, distroversion, arch):
    """
        Generates one huge list of buildsteps combining all components
        for all dists, all versions and all hardware arches. 

        The alternative is to have a huge list of Builders and that is even
        more ugly.
    """

    lsbdistcodename=distrodict[distro]["version"][distroversion]
    buildername = "%s_%s_%s" % (distro, distroversion, arch)
    hgtag = '1.0.5'
    date = time.strftime("%Y%m%d-%H%M%S")

    f = BuildFactory()

    # Start by making a result folder where all our (deb) packages will go
    # into. 
    f.addSteps([
        MasterShellCommand(command=["mkdir", "-p", 
            WithProperties('/tmp/incoming/%(buildername)s'),]),
    ])

    for component in components:
        


        XLSsteps(f, component)


        # REVISION
        rev = SetProperty(command='hg id -n | /bin/sed -e "s/+$//"', property="rev")

        pre_tipmost = SetProperty(command='/bin/bash -c \"hg tags | cut -f 1 -d \' \' | head -n 2 | tail -n 1\"', property="pre_tipmost") 

        tipmost = SetProperty(command=WithProperties('/bin/bash -c \"if [[ %(pre_tipmost)s == \'tip\' ]] ; then echo \'0.0.0\' ; else echo %(pre_tipmost)s;  fi\"'),  property="tipmost") 


        # --- RPM SPECIFIC

        # We need the .spec name to feed to the mock --buildsrpm later on...
        set_spec_name = SetProperty(command='/bin/bash -c "ls rpm/*.spec | head -n 1"',  property="spec_name")


        #Bah.
        copy_folder = ShellCommand(command=['cp', 
                                            '-a', 
                                            '.', 
                                            WithProperties("../%(rpm_name)s-%(rpm_version)s"),])

        # This assumes that there is only ONE spec file!
        set_rpm_name = SetProperty(command='/bin/bash -c "grep ^Name: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_name")

        set_rpm_version = SetProperty(command='/bin/bash -c "grep ^Version: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_version")

        set_rpm_repopath = SetProperty(command=['echo', WithProperties("/srv/repository/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/"),], property="rpm_repopath")

        rpm_createrepo = ShellCommand(command=['/bin/bash', '-c', WithProperties('cd %(rpm_repopath)s && createrepo .'),], env=env)

        # Going to upload to a tmp folder:
        rpm_upload_to_master = DirectoryUpload(slavesrc=WithProperties("%(rpm_repopath)s/"), masterdest=WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'))

        # Feeding tmp folder to rpmsign script:
        rpm_master_sign = MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/rpmsign.py',
                            WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                    )
                
        # Remove the temporary incoming folder:
        rpm_master_remove = MasterShellCommand(command=['rm', '-rf',
                            WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                    )

        # Officially decided that we will be using bzip2, not gzip. Any .spec
        # referring to gz files should fail.
        rpm_tbz = ShellCommand(command=['tar', 
                                    'jcf',
                                    WithProperties('../%(rpm_name)s-%(rpm_version)s.tar.bz2'), 
                                    WithProperties('../%(rpm_name)s-%(rpm_version)s'), 
                                    ])

        # Have mock build a SRPM
        rpm_mock_buildsrpm = ShellCommand(command=['mock', 
                                    '--buildsrpm',
                                    WithProperties('--spec=%(spec_name)s'),
                                    WithProperties('--sources=%(workdir)s/'),
                                    WithProperties('--resultdir=%(workdir)s/'),
                                    WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                    ])

        # Fetch the name of the srpm:
        get_src_rpm_name = SetProperty(command='/bin/bash -c "ls ../ | grep .src.rpm"',  property="src_rpm")

        # Feed SRPM to build RPM
        rpm_mock_rebuild = ShellCommand(command=['mock', 
                                    '--rebuild',
                                    WithProperties('../%(src_rpm)s'), 
                                    WithProperties('--resultdir=/srv/repository/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/'),
                                    '-r',
                                    WithProperties('%(distro)s-%(distroversion)s-%(arch)s'),
                                    ], env=env)

        rpm_master_mkdir = MasterShellCommand(command=["mkdir", 
                                    "-p", 
                                    WithProperties('%(rpm_repopath)s'),
                                    ],
                                    )
        # Clean up srpm:
        clean_src_rpm = ShellCommand(command=['/bin/bash', '-c', 
                                    WithProperties('rm -rf ../%(src_rpm)s'),])

                
        # Clean up the mock env
        rpm_mock_clean = ShellCommand(command=['mock', 
                                    '--clean',
                                    WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                    ])


        # Createrepo on master
        rpm_master_createrepo = MasterShellCommand(command=['/bin/bash', '-c', 
                                    WithProperties('createrepo %(rpm_repopath)s'),
                                    ], env=env)

        rpm_master_copy = MasterShellCommand(command=['/bin/bash', '-c', 
                                    WithProperties('cp /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm %(rpm_repopath)s'),],env=env)

        rpm_master_clean = MasterShellCommand(command=['/bin/bash', '-c', 
                                    WithProperties('rm -rf /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm '),],env=env)
        # --- END OF RPM SPECIFIC STEPS.

        # --- START DEB SPECIFIC STEPS

        # Get the name of the source package
        src_name = SetProperty(command="/bin/bash -c \" if [[ -e debian/control ]] ; then cat debian/control | grep ^Source: | sed -e 's/^Source: //'; else exit 1; fi\"", 
                                property="src_name", 
                                env=env,
                                )

        # Now that we have the version nr, we should be 
        debchange = ShellCommand(command=['debchange', 
                                    '--force-bad-version', 
                                    '--newversion', 
                                    WithProperties('%(newver)s'), 
                                    'autogenerated', 
                                    '--force-distribution', 
                                    '--distribution', 
                                    WithProperties('%(lsbdistcodename)s')],
                                    )


        # Now that we have a .dsc, we can build a source package:
        dpkg_buildpackage = ShellCommand(command=['dpkg-buildpackage', 
                                        '-us', 
                                        '-uc', 
                                        '-d', 
                                        '-S', 
                                        '-sa', 
                                        '-i', 
                                        '-I',
                                        ])

        # Now that we have a source package, we can build a binary package:
        pbuilder = ShellCommand(command=['pbuilder', 
                                        'build', 
                                        '--hookdir', 
                                        '/srv/hook', 
                                        '--basetgz', 
                                        WithProperties('/var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz'), 
                                        '--buildresult', 
                                        WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s/'), 
                                        WithProperties('../%(src_name)s_%(newver)s.dsc'), 
                                        ])
        
        # --- END DEBIAN SPECIFIC

        version_id = ShellCommand(command=['/bin/bash', '-c', WithProperties('echo %(tipmost)s > version.id')])

        # buildbot master (twistd) runs with a strict (unconfigurable) umask.
        # I have changed the twistd source file to set umask to 022. Therefor,
        # these steps are no longer strictly needed. However: better safe than
        # sorry.
        repo_permission_fix = MasterShellCommand(command=[
                        '/bin/bash', '-c', ' find %s -type d -perm 700 -exec chmod 755 {} \;' % debrepo,
            ])
        repo_permission_fix_files = MasterShellCommand(command=[
                        '/bin/bash', '-c', ' find %s -type f -perm 600 -exec chmod 644 {} \;' % debrepo,
            ])

        # Look up in a dictionary if we're going to build RPMs or DEBs
        pkg_method = distrodict[distro]["pkg"]

        hgrepo = "http://hg.openpanel.com/%s/" % component

        # Generic steps:

        f.addSteps([
            SetProperty(command=['echo', "%s" % date, ], property="date"),
            SetProperty(command=['echo', "%s" % lsbdistcodename, ], property="lsbdistcodename"),
            SetProperty(command=['echo', "%s" % arch, ], property="arch"),
            SetProperty(command=['echo', "%s" % distro, ], property="distro"),
            SetProperty(command=['echo', "%s" % distroversion, ], property="distroversion"),
            SetProperty(command=['echo', "%s" % component, ], property="component"),
            

            pre_tipmost,
            tipmost,
            rev,
            SetProperty(command=['echo', WithProperties('%(tipmost)s-%(rev)s'), '+%s' % (date), '.1', '+%s' % lsbdistcodename,], property="newver"),
            SetProperty(command=['/bin/bash', '-c', WithProperties('echo %(newver)s | sed -e \"s/\ //g\"'),  ], property="newver"),
            ])

        # Packaging method dependent steps:
        if pkg_method is "deb":
            f.addSteps([
                src_name,
                
                # Clean up previous results dir if exists, just to make sure. 
                ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
                # Create a results folder to place the .debs in (before passing it onto
                # reprepro)
                ShellCommand(command=['mkdir', '-p', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
        
                debchange,
                version_id,
                dpkg_buildpackage, 
                repo_permission_fix,
                repo_permission_fix_files,
                # Create a tmp apt repo right here on the spot:
                # This needs to be done here or else pbuilder will bork on not
                # finding Packages.gz on this location.
                MasterShellCommand(command=[
                        '/bin/bash', '-c', 'cd /tmp/incoming/%s && dpkg-scanpackages -m . /dev/null | gzip -9c >Packages.gz' % buildername,
                ]),
                pbuilder,
                # Upload all components to one folder that will get pushed to
                # the repository in one go. 
                DirectoryUpload(slavesrc=WithProperties("/var/cache/pbuilder/result/%(src_name)s_%(newver)s"), masterdest=WithProperties("/tmp/incoming/%(buildername)s")),
                
                # Clean up after our selves:
                ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),

                # Create a tmp apt repo right here on the spot:
                MasterShellCommand(command=[
                        '/bin/bash', '-c', 'cd /tmp/incoming/%s && dpkg-scanpackages -m . /dev/null | gzip -9c >Packages.gz' % buildername,
                ]),

                # Debug output for me:
                ShellCommand(command=['echo', 'DEBUG:', WithProperties('%(ex)s, %(src_name)s %(component)s %(date)s %(lsbdistcodename)s %(arch)s %(tipmost)s '),]),
            ])

        # steps for building RPMs:
        if pkg_method is "rpm":
            f.addSteps([
                set_spec_name,
                set_rpm_name,
                set_rpm_version,
                copy_folder,
                set_rpm_repopath,
                rpm_createrepo,
                rpm_master_mkdir,
                rpm_tbz, 
                rpm_mock_buildsrpm,
                get_src_rpm_name,
                rpm_mock_rebuild,
                clean_src_rpm, 
                rpm_upload_to_master,
                rpm_master_sign,
                rpm_mock_clean,
            ])

    # Postprocessing RPM
    if pkg_method is "rpm":
        '''
            Steps to run after all rpm components have finished
        '''
        f.addSteps([
                rpm_master_copy,
                rpm_master_clean,
                rpm_master_createrepo,
        ])

    if pkg_method is "deb":
        '''
            Steps to run after all Debian/Ubuntu components have finished:
        '''
        f.addSteps([
            # Add all files in incoming folder to repository:
            MasterShellCommand(command=['reprepro', 
                                '-V', 
                                '--waitforlock', 
                                '12', 
                                '-b', 
                                '%s' % debrepo,
                                'processincoming',
                                WithProperties("%(distro)s_%(distroversion)s_%(arch)s"),
                                ],
                        ),

            # Clean up:
            MasterShellCommand(command=['rm', '-rf', '/tmp/incoming/%s_%s_%s/*' % (dist,version,arch),
               ],
            ),
        ])
    

    # Trigger the rsync to bob in a seperate buildstep so it gets queued
    # nicely. This way, no 2 rsyncs can be done at the same time.
    f.addSteps([
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'PostProcess', '-p', WithProperties('{"distro": "%(distro)s", "distroversion": "%(distroversion)s", "arch": "%(arch)s"}')]),
    ])

    # Now that we have all the steps in a factory, we can hand the factory back
    # to the Builder:
    return f


# Create a list of components. 
# Each component corresponds with an hg repo on hg.openpanel.com.
# The order in which these components are listed here is the order in which
# a Builder will build them. 

components=[
        'grace',
        # FIXME: Not debianized! 'grace-util',
        # FIXME: Not debianized! 'grace-site',
        #'opencore',
        #'opencore-ssl',
        #'opencli',
        #'authd',
        #'openpanel-gui',
        ## FIXME: Not debianized! 'vm-image-builder',
        #'validatepem',
        #'vacationdrop',
        #'swupd',
        ## FIXME: Not debianized! 'pound-sslpatched',
        #'logax',
        #'limadaemon',
        ## FIXME: Not debianized! 'db4dump',
        ##'coreval',
        #'coreunreg',
        ## FIXME: Not debianized 'contrib/WebApps.module',
        ## FIXME: Not debianized 'autobuilder',
        ## FIXME: Not debianized 'WebDAV.module',
        #'User.module',
        #'Stub.module',
        ## FIXME: Not debianized 'Storpel.module',
        #'SpamAssassin.module',
        #'SoftwareUpdate.module',
        #'SSH.module',
        #'Pptpd.module',
        #'PostfixCourier.module',
        ## FIXME: I Don't exist? 'OpenSwan.module',
        #'Networking.module',
        #'MySQL.module',
        #'Keepalived.module',
        #'IPTables.module',
        #'FTP.module',
        #'Domain.module',
        #'DNSDomain.module',
        #'ApacheForward.module',
        #'Apache2.module',
        #'Amavis.module',
        #'AWStats.module',
        ## Disabling due to bug #1031 'LIMA.module',
        #'openapp/openpanel-openapp-pureftpd-auth',
        #'openapp/openpanel-openapp-mysql-artwork',
        #'openapp/openpanel-openapp-mod-wordpress',
        #'openapp/openpanel-openapp-mod-user',
        #'openapp/openpanel-openapp-mod-smtp',
        #'openapp/openpanel-openapp-mod-ruby',
        #'openapp/openpanel-openapp-mod-mysql',
        #'openapp/openpanel-openapp-mod-joomla',
        #'openapp/openpanel-openapp-mod-drupal',
        #'openapp/openpanel-openapp-mod-cron-apt',
        #'openapp/openpanel-openapp-mod-backup',
        #'openapp/openpanel-openapp-mod-apache2',
        #'openapp/openpanel-openapp-gui',
        #'openapp/openpanel-openapp-call',
        #'openapp/openapp-xtrabackup',
        #'openapp/openapp-wordpress-installer',
        #'openapp/openapp-tuning',
        #'openapp/openapp-tomcat',
        #'openapp/openapp-symfony',
        #'openapp/openapp-ruby',
        #'openapp/openapp-phpmyadmin-installer',
        #'openapp/openapp-mysql',
        #'openapp/openapp-lamp',
        #'openapp/openapp-joomla-installer',
        #'openapp/openapp-drupal',
        #'openapp/openapp-backup',
        #'openapp/openapp-awstats',
        ## FIXME: fails due to ./configure not existing: 'contrib/MySQLBackup.module',
        ## FIXME: Not debianized 'contrib/FolderPassword.module',
        ## NOT PART OF THIS: 'buildbot-config',
    ]


# A special builder that does postprocessing stuff
# (runs reprepro and syncs to bob.openpanel.com)
c['builders'].append(
    BuilderConfig(name="PostProcess",
    slavenames='postprocess-slave',  # <-- required parameter, even if no slave buildsteps.
    factory=PostProcess("debian")))

c['builders'].append(
    BuilderConfig(name="A-TestBuilder",
    slavenames='postprocess-slave',  # <-- required parameter, even if no slave buildsteps.
    factory=TestFactory("debian")))


# Loop through all our different supported distros and versions and create
# builders for them:
for dist in distrodict:
    # Assign slaves based on distro:
    if dist == "debian":
        slavenames = ['debian6-amd64']
    if dist == "ubuntu":
        slavenames = ['debian6-amd64']
    if dist == "centos":
        slavenames = ['centos5-slave']

    for version in distrodict[dist]['version']:
        for arch in distrodict[dist]['architectures']:
                name = "%s_%s_%s" % (dist , version , arch)

                c['builders'].append(
                    BuilderConfig(name=name,
                    slavenames=slavenames,
                    factory=make_factory(dist, version, arch))) 


# -- SCHEDULERS
# These define when a builder is called.

# Start out empty:
c['schedulers'] = []

# Since we have all builders defined, we can add schedules to them.
for builder in c['builders']:
    # This enables calling builders remotely:
    # (specifically 'change_filter' does that)
    name = builder.name
    c['schedulers'].append(
        SingleBranchScheduler(
            name = name,
            change_filter = ChangeFilter(project=name),
            treeStableTimer = 1, 
            builderNames = [name],
        ),)
    # Scheduled (time based) builds:
    c['schedulers'].append(
        timed.Nightly(
            name = 'nightly_%s' % name,
            builderNames=[name],
            hour=13,
            minute=00,
            branch="",
        ),
    ),



####### STATUS TARGETS

# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.

c['status'] = []


# Users that can do stuff:
users = [('bob', 'secret-pass'), ('jill', 'super-pass')]

# What can be done by those users:
authz = Authz(auth=BasicAuth(users),
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True,
    #PRODforceBuild = 'auth',
    forceAllBuilds = False,
    pingBuilder = False,
    stopBuild = 'auth',
    stopAllBuilds = False,
    cancelPendingBuild = 'auth',
)

# -- This helps to enable buildbot to allow remotely triggered builds over
#    http:
c['status'].append(html.WebStatus(http_port=8010, authz=authz, 
        change_hook_dialects={
                'openpanel_hook': True,
            }
        ))

from buildbot.changes import pb
c['changes'] = pb.PBChangeSource(port=9989)


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "OpenPanel"
c['titleURL'] = "http://openpanel.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

