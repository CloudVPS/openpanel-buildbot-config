# -*- python -*-
# ex: set syntax=python:

import time 
from buildbot import manhole
from buildbot.config import BuilderConfig
from buildbot.buildslave import BuildSlave
from buildbot.process.factory import BuildFactory
from buildbot.process.properties import Property, Properties, WithProperties
from buildbot.steps.source import Mercurial
from buildbot.steps.shell import ShellCommand, SetProperty
from buildbot.process.buildstep import LoggingBuildStep, BuildStep, RemoteShellCommand
from buildbot.schedulers.basic import SingleBranchScheduler
from buildbot.schedulers import timed
from buildbot.changes.filter import ChangeFilter
from buildbot.status import html
from buildbot.status.web import authz
from buildbot.process import buildstep, factory, properties
from buildbot.steps.master import MasterShellCommand
from buildbot.status import results 
from buildbot.steps.transfer import FileUpload, DirectoryUpload
from buildbot.status.html import WebStatus
from buildbot.status.web.authz import Authz
from buildbot.status.web.auth import BasicAuth


import commands
import os

repositories = {'dev': '/srv/repository', 'stable': '/srv/repository-stable'}

# This checks/creates an empty Debian repo based on settings in /srv/repository/conf
# everytime buildbot rebuilds it's config. 
# If the repo is not there, the build will fail. 
# However, if this command runs every build, some build somewhere will fail due to
# lockfiles.

for repo in repositories:
    commands.getoutput('reprepro -b %s export' % repo)


# This is the dictionary that the buildmaster pays attention to. We also use
# a shorter alias to save typing.
c = BuildmasterConfig = {}

c['builders'] = []


####### BUILDSLAVES
c['slaves'] = [
                BuildSlave("debian6-amd64", "pass", max_builds=1), 
                BuildSlave("centos5-slave", "pass", max_builds=1), 
                BuildSlave("postprocess-slave", "pass", max_builds=1),  # -- See comment at
                                                                        #    slave definition.
                ]

# Port slaves will connect to:
c['slavePortnum'] = 9989

# Set global env variables to be used in buildsteps here.
# (Remember to use env=env when using shellcommands!)
env={'DEBFULLNAME': 'OpenPanel packager', 'DEBEMAIL': 'packages@openpanel.com'}

# This is a dictionary of distribution specific attributes needed to config,
# make, make install using distro specific tools and settings. 
# Fragmentation is a joy!
distrodict = {
            "debian": {
                "pkg": "deb",
                "version": {
                    "5": "lenny",
                    "6": "squeeze",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "ubuntu": {
                "pkg": "deb",
                "version": {
                    "10.04": "lucid",
                    "11.04": "natty",
                    },
                "architectures": [
                        "amd64", 
                        "i386",
                    ],
                },
            "centos": {
                "pkg": "rpm",
                "version": {
                    "5": "centos5",
                    },
                "architectures": [
                        "x86_64", 
                        "i386",
                    ],
                },
            }
    
# Create a list of components, 
# with lists of supported distros (pkging methods, really). 
# Each component corresponds with an hg repo on hg.openpanel.com.
# The order in which these components are listed here is the order in which
# a Builder will build them. 
all_components=[
        ['grace', ["deb", "rpm"]],
        ['grace-util', ["FIXME"]],
        ['grace-site', ["FIXME"]],
        ['opencore', ["deb", ]],
        ['opencore-ssl', ["deb", ]],
        ['opencli', ["deb", ]],
        ['authd', ["deb"]],
        ['openpanel-gui', ["deb"]],
        ['vm-image-builder', ["FIXME"]],
        ['validatepem', ["deb"]],
        ['vacationdrop', ["deb"]],
        ['swupd', ["deb"]],
        ['pound-sslpatched',["FIXME"]],
        ['logax', ["deb"]],
        ['limadaemon', ["deb"]],
        ['db4dump',["FIXME"]],
        ['coreval', ["deb"]],
        ['coreunreg', ["deb"]],
        ['contrib/WebApps.module',["FIXME"]],
        ['autobuilder',["FIXME"]],
        ['WebDAV.module', ["FIXME"]],
        ['User.module', ["deb"]],
        ['Stub.module', ["deb"]],
        ['Storpel.module',["FIXME"]],
        ['SpamAssassin.module', ["deb"]],
        ['SoftwareUpdate.module', ["deb"]],
        ['SSH.module', ["deb"]],
        ['Pptpd.module', ["deb"]],
        ['PostfixCourier.module', ["deb"]],
        ['OpenSwan.module',["FIXME"]],
        ['Networking.module', ["deb"]],
        ['MySQL.module', ["deb"]],
        ['Keepalived.module', ["deb"]],
        ['IPTables.module', ["deb"]],
        ['FTP.module', ["deb"]],
        ['Domain.module', ["deb"]],
        ['DNSDomain.module', ["deb"]],
        ['ApacheForward.module', ["deb"]],
        ['Apache2.module', ["deb"]],
        ['Amavis.module', ["deb"]],
        ['AWStats.module', ["deb"]],
        ['LIMA.module',["FIXME"]],
        ['openapp/openpanel-openapp-pureftpd-auth', ["deb"]],
        ['openapp/openpanel-openapp-mysql-artwork', ["deb"]],
        ['openapp/openpanel-openapp-mod-wordpress', ["deb"]],
        ['openapp/openpanel-openapp-mod-user', ["deb"]],
        ['openapp/openpanel-openapp-mod-smtp', ["deb"]],
        ['openapp/openpanel-openapp-mod-ruby', ["deb"]],
        ['openapp/openpanel-openapp-mod-mysql', ["deb"]],
        ['openapp/openpanel-openapp-mod-joomla', ["deb"]],
        ['openapp/openpanel-openapp-mod-drupal', ["deb"]],
        ['openapp/openpanel-openapp-mod-cron-apt', ["deb"]],
        ['openapp/openpanel-openapp-mod-backup', ["deb"]],
        ['openapp/openpanel-openapp-mod-apache2', ["deb"]],
        ['openapp/openpanel-openapp-gui', ["deb"]],
        ['openapp/openpanel-openapp-call', ["deb"]],
        ['openapp/openapp-xtrabackup', ["deb"]],
        ['openapp/openapp-wordpress-installer', ["deb"]],
        ['openapp/openapp-tuning', ["deb"]],
        ['openapp/openapp-tomcat', ["deb"]],
        ['openapp/openapp-symfony', ["deb"]],
        ['openapp/openapp-ruby', ["deb"]],
        ['openapp/openapp-phpmyadmin-installer', ["deb"]],
        ['openapp/openapp-mysql', ["deb"]],
        ['openapp/openapp-lamp', ["deb"]],
        ['openapp/openapp-joomla-installer', ["deb"]],
        ['openapp/openapp-drupal', ["deb"]],
        ['openapp/openapp-backup', ["deb"]],
        ['openapp/openapp-awstats', ["deb"]],
        ['contrib/MySQLBackup.module', ["FIXME"]],
        ['contrib/FolderPassword.module', ["FIXME"]],
        ['buildbot-config', ["NOT PACKAGED"]],   # -- No need to include self
    ]



def do_release(tag):
    '''
        Determine if this is a release or a nightly (or something else?).

        Probably not worthy of a function (yet).
    '''
    if tag is "tip":
        do_release = False
    else:
        do_release = True
    return do_release

def MercurialXLS(f, hgrepo, tag):
    '''
        Internal mercurial function didn't do what needed to be done (use tags). This is
        more dirty, yet does. 
    '''

    # Define BuildSteps:

    set_hgworkdir = SetProperty(command='echo build', property="hgworkdir")
    set_hgrepo = SetProperty(command='echo %s' % hgrepo, property="hgrepo")
    set_hgtag = SetProperty(command='echo %s' % tag, property="hgtag")
    hgclean = ShellCommand(command=['/bin/bash', '-c', WithProperties('rm -rf ../%(hgworkdir)s'),])
    hgclone = ShellCommand(command=['/bin/bash', '-c', WithProperties('hg clone %(hgrepo)s ../%(hgworkdir)s -r %(hgtag)s'),])

    # Add steps to factory:
    f.addSteps([
        set_hgworkdir,
        set_hgrepo,
        set_hgtag,
        hgclean,
        hgclone,
    ])
    return f

def TestFactory(distro):
    '''
        This factory is only here for testing purposes while mucking about with
        buildbot without disturbing other code or builds.
    '''

    f = BuildFactory()

    # This triggers other Builders remotely. 
    f.addSteps([
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'grace_debian_6_amd64', ]),
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'grace_debian_6_i386', ]),
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'grace_debian_5_amd64', ]),
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'grace_debian_5_i386', ]),
    ])
    return f
    
def PostProcess(distro):
    
    '''
        This factory is used for buildsteps (mostly on the master) that publish
        the build results to where ever you need. 

        The idea of doing this in a seperate factory instead of the generic one
        is that it should allow for more flexibility. If not, then this can be
        dropped and added to the main factory.

        In it's current form, it's only added value is that doing it this way,
        we make use of buildbots queueing. Thus there shouldn't be more than 1
        rsync at a time.
    
        Currently there are only steps for Debian/Ubuntu as it includes the
        publishing of the .deb files to the public repository.
    
    '''

    f = BuildFactory()
    f.addSteps([
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/synctobob.py',], env=env),
    ])
    return f
    



def make_distro_factory(distro, distroversion, arch, tag):
    """
        Builds all components for 1 specified distro. 
    """

    f = BuildFactory()
    for component in components:
        make_factory(f, distro, distroversion, arch, component, tag)
        

    # Trigger the rsync to bob in a seperate buildstep so it gets queued
    # nicely. This way, no 2 rsyncs can be done at the same time.
    f.addSteps([
        MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'PostProcess', '-p', WithProperties('{"distro": "%(distro)s", "distroversion": "%(distroversion)s", "arch": "%(arch)s"}')]),
    ])

    return f

def make_component_factory(component, distro, distroversion, arch, tag):
    """
        
    """
    f = BuildFactory()
    make_factory(f, distro, distroversion, arch, component, tag)
        

    # Trigger the rsync to bob in a seperate buildstep so it gets queued
    # nicely. This way, no 2 rsyncs can be done at the same time.
    f.addSteps([
         MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/post_build_request.py', '-u', '/change_hook/openpanel_hook', '--project', 'PostProcess', '-p', WithProperties('{"distro": "%(distro)s", "distroversion": "%(distroversion)s", "arch": "%(arch)s"}')]),
     ])

    return f

def make_factory(f, distro, distroversion, arch, component, tag):
    '''
        This function does the brunt of the work. It is to be called after the
        logic has been determined what component to build. 

        In other words this makes: 
            one component
            for one distro
            for one distroversion
            on one arch
            of one hg tag
    '''

    lsbdistcodename=distrodict[distro]["version"][distroversion]
    buildername = "%s_%s_%s" % (distro, distroversion, arch)
    date = time.strftime("%Y%m%d-%H%M%S")

    release = do_release(tag)

    if release is True:
        debrepo = repositories['stable']
    else:
        debrepo = repositories['dev']


    # Start by making a result folder where all our (deb) packages will go
    # into. 
    f.addSteps([
        MasterShellCommand(command=["mkdir", "-p", 
            WithProperties('/tmp/incoming/%(buildername)s'),]),
    ])

    hgrepo = "http://hg.openpanel.com/%s/" % component
    # Do a mercurial clone:

    # Do a clone of hgrepo with -r tag:
    MercurialXLS(f, hgrepo, tag)

    
    # Copying local variables to Properties. 
    set_date = SetProperty(command=['echo', "%s" % date, ], property="date") # FIXME should be done on slave
    set_lsbdistcodename = SetProperty(command=['echo', "%s" % lsbdistcodename, ], property="lsbdistcodename")
    set_arch = SetProperty(command=['echo', "%s" % arch, ], property="arch")
    set_distro = SetProperty(command=['echo', "%s" % distro, ], property="distro")
    set_distroversion = SetProperty(command=['echo', "%s" % distroversion, ], property="distroversion")
    set_component = SetProperty(command=['echo', "%s" % component, ], property="component")
    set_debrepo = SetProperty(command=['echo', "%s" % debrepo, ], property="debrepo")
    set_ex = SetProperty(command=['echo', "1" , ], property="ex")

    # REVISION
    rev = SetProperty(command='hg id -n | /bin/sed -e "s/+$//"', property="rev")

    pre_tipmost = SetProperty(command='/bin/bash -c \"hg tags | cut -f 1 -d \' \' | head -n 2 | tail -n 1\"', property="pre_tipmost") 

    tipmost = SetProperty(command=WithProperties('/bin/bash -c \"if [[ %(pre_tipmost)s == \'tip\' ]] ; then echo \'0.0.0\' ; else echo %(pre_tipmost)s;  fi\"'),  property="tipmost") 


    # --- RPM SPECIFIC

    # We need the .spec name to feed to the mock --buildsrpm later on...
    set_spec_name = SetProperty(command='/bin/bash -c "ls rpm/*.spec | head -n 1"',  property="spec_name")


    #Bah.
    copy_folder = ShellCommand(command=['cp', 
                                        '-a', 
                                        '.', 
                                        WithProperties("../%(rpm_name)s-%(rpm_version)s"),])

    # This assumes that there is only ONE spec file!
    set_rpm_name = SetProperty(command='/bin/bash -c "grep ^Name: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_name")

    set_rpm_version = SetProperty(command='/bin/bash -c "grep ^Version: rpm/*.spec | xargs | cut -d \":\" -f 2 "',  property="rpm_version")

    set_rpm_repopath = SetProperty(command=['echo', WithProperties("%(debrepo)s/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/"),], property="rpm_repopath")

    rpm_createrepo = ShellCommand(command=['/bin/bash', '-c', WithProperties('cd %(rpm_repopath)s && createrepo .'),], env=env)

    # Going to upload to a tmp folder:
    rpm_upload_to_master = DirectoryUpload(slavesrc=WithProperties("%(rpm_repopath)s/"), masterdest=WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'))

    # Feeding tmp folder to rpmsign script:
    rpm_master_sign = MasterShellCommand(command=['/home/buildmaster/buildbot-config/bin/rpmsign.py',
                        WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                )
            
    # Remove the temporary incoming folder:
    rpm_master_remove = MasterShellCommand(command=['rm', '-rf',
                        WithProperties('/tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s'),],
                )

    # Officially decided that we will be using bzip2, not gzip. Any .spec
    # referring to gz files should fail.
    rpm_tbz = ShellCommand(command=['tar', 
                                'jcf',
                                WithProperties('../%(rpm_name)s-%(rpm_version)s.tar.bz2'), 
                                WithProperties('../%(rpm_name)s-%(rpm_version)s'), 
                                ])

    # Have mock build a SRPM
    rpm_mock_buildsrpm = ShellCommand(command=['mock', 
                                '--buildsrpm',
                                WithProperties('--spec=%(spec_name)s'),
                                WithProperties('--sources=%(workdir)s/'),
                                WithProperties('--resultdir=%(workdir)s/'),
                                WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                ])

    # Fetch the name of the srpm:
    get_src_rpm_name = SetProperty(command='/bin/bash -c "ls ../ | grep .src.rpm"',  property="src_rpm")

    # Feed SRPM to build RPM
    rpm_mock_rebuild = ShellCommand(command=['mock', 
                                '--rebuild',
                                WithProperties('../%(src_rpm)s'), 
                                WithProperties('--resultdir=%(debrepo)s/yum/dev/%(distro)s/%(distroversion)s/%(arch)s/RPMS/'),
                                '-r',
                                WithProperties('%(distro)s-%(distroversion)s-%(arch)s'),
                                ], env=env)

    rpm_master_mkdir = MasterShellCommand(command=["mkdir", 
                                "-p", 
                                WithProperties('%(rpm_repopath)s'),
                                ],
                                )
    # Clean up srpm:
    clean_src_rpm = ShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('rm -rf ../%(src_rpm)s'),])

            
    # Clean up the mock env
    rpm_mock_clean = ShellCommand(command=['mock', 
                                '--clean',
                                WithProperties('-r%(distro)s-%(distroversion)s-%(arch)s'),
                                ])


    # Createrepo on master
    rpm_master_createrepo = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('createrepo %(rpm_repopath)s'),
                                ], env=env)

    rpm_master_copy = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('cp /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm %(rpm_repopath)s'),],env=env)

    rpm_master_clean = MasterShellCommand(command=['/bin/bash', '-c', 
                                WithProperties('rm -rf /tmp/incoming/%(distro)s_%(distroversion)s_%(arch)s/*.rpm '),],env=env)
    # --- END OF RPM SPECIFIC STEPS.

    # --- START DEB SPECIFIC STEPS

    # Get the name of the source package
    src_name = SetProperty(command="/bin/bash -c \" if [[ -e debian/control ]] ; then cat debian/control | grep ^Source: | sed -e 's/^Source: //'; else exit 1; fi\"", 
                            property="src_name", 
                            env=env,
                            )

    # Now that we have the version nr, we should be 
    debchange = ShellCommand(command=['debchange', 
                                '--force-bad-version', 
                                '--newversion', 
                                WithProperties('%(newver)s'), 
                                'autogenerated', 
                                '--force-distribution', 
                                '--distribution', 
                                WithProperties('%(lsbdistcodename)s')],
                                )


    # Now that we have a .dsc, we can build a source package:
    dpkg_buildpackage = ShellCommand(command=['dpkg-buildpackage', 
                                    '-us', 
                                    '-uc', 
                                    '-d', 
                                    '-S', 
                                    '-sa', 
                                    '-i', 
                                    '-I',
                                    ])

    # Now that we have a source package, we can build a binary package:
    pbuilder = ShellCommand(command=['pbuilder', 
                                    'build', 
                                    '--hookdir', 
                                    '/srv/hook', 
                                    '--basetgz', 
                                    WithProperties('/var/cache/pbuilder/%(lsbdistcodename)s-%(arch)s.tgz'), 
                                    '--buildresult', 
                                    WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s/'), 
                                    WithProperties('../%(src_name)s_%(newver)s.dsc'), 
                                    ])
    
    # --- END DEBIAN SPECIFIC

    version_id = ShellCommand(command=['/bin/bash', '-c', WithProperties('echo %(tipmost)s > version.id')])

    # buildbot master (twistd) runs with a strict (unconfigurable) umask.
    # I have changed the twistd source file to set umask to 022. Therefor,
    # these steps are no longer strictly needed. However: better safe than
    # sorry.

    repo_permission_fix = MasterShellCommand(command=[
                    '/bin/bash', '-c', ' find %s -type d -perm 700 -exec chmod 755 {} \;' % debrepo,
        ])
    repo_permission_fix_files = MasterShellCommand(command=[
                    '/bin/bash', '-c', ' find %s -type f -perm 600 -exec chmod 644 {} \;' % debrepo,
        ])

    # Look up in a dictionary if we're going to build RPMs or DEBs
    pkg_method = distrodict[distro]["pkg"]

    hgrepo = "http://hg.openpanel.com/%s/" % component

    # Generic steps:

    f.addSteps([
        set_date,
        set_lsbdistcodename,
        set_arch,
        set_distro,
        set_distroversion,
        set_component,
        set_debrepo,
        set_ex,
        pre_tipmost,
        tipmost,
        rev,
        SetProperty(command=['echo', WithProperties('%(tipmost)s-%(rev)s'), '+%s' % (date), '.1', '+%s' % lsbdistcodename,], property="newver"),
        SetProperty(command=['/bin/bash', '-c', WithProperties('echo %(newver)s | sed -e \"s/\ //g\"'),  ], property="newver"),
        ])

    # Packaging method dependent steps:
    if pkg_method is "deb":
        f.addSteps([
            src_name,
            
            # Clean up previous results dir if exists, just to make sure. 
            ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
            # Create a results folder to place the .debs in (before passing it onto
            # reprepro)
            ShellCommand(command=['mkdir', '-p', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),
    
            debchange,
            version_id,
            dpkg_buildpackage, 
            repo_permission_fix,
            repo_permission_fix_files,
            # Create a tmp apt repo right here on the spot:
            # This needs to be done here or else pbuilder will bork on not
            # finding Packages.gz on this location.
            MasterShellCommand(command=[
                    '/bin/bash', '-c', 'cd /tmp/incoming/%s && dpkg-scanpackages -m . /dev/null | gzip -9c >Packages.gz' % buildername,
            ]),
            pbuilder,
            # Upload all components to one folder that will get pushed to
            # the repository in one go. 
            DirectoryUpload(slavesrc=WithProperties("/var/cache/pbuilder/result/%(src_name)s_%(newver)s"), masterdest=WithProperties("/tmp/incoming/%(buildername)s")),
            
            # Clean up after our selves:
            ShellCommand(command=['rm', '-rf', WithProperties('/var/cache/pbuilder/result/%(src_name)s_%(newver)s')]),

            # Create a tmp apt repo right here on the spot:
            MasterShellCommand(command=[
                    '/bin/bash', '-c', 'cd /tmp/incoming/%s && dpkg-scanpackages -m . /dev/null | gzip -9c >Packages.gz' % buildername,
            ]),

            # Debug output for me:
            ShellCommand(command=['echo', 'DEBUG:', WithProperties('%(ex)s, %(src_name)s %(component)s %(date)s %(lsbdistcodename)s %(arch)s %(tipmost)s '),]),
        ])

    # steps for building RPMs:
    if pkg_method is "rpm":
        f.addSteps([
            set_spec_name,
            set_rpm_name,
            set_rpm_version,
            copy_folder,
            set_rpm_repopath,
            rpm_createrepo,
            rpm_master_mkdir,
            rpm_tbz, 
            rpm_mock_buildsrpm,
            get_src_rpm_name,
            rpm_mock_rebuild,
            clean_src_rpm, 
            rpm_upload_to_master,
            rpm_master_sign,
            rpm_mock_clean,
        ])

    # Postprocessing RPM
    if pkg_method is "rpm":
        '''
            Steps to run after all rpm components have finished
        '''
        f.addSteps([
                rpm_master_copy,
                rpm_master_clean,
                rpm_master_createrepo,
        ])

    if pkg_method is "deb":
        '''
            Steps to run after all Debian/Ubuntu components have finished:
        '''
        f.addSteps([
            # Add all files in incoming folder to repository:
            MasterShellCommand(command=['reprepro', 
                                '-V', 
                                '--waitforlock', 
                                '12', 
                                '-b', 
                                '%s' % debrepo,
                                'processincoming',
                                WithProperties("%(distro)s_%(distroversion)s_%(arch)s"),
                                ],
                        ),

            # Clean up:
            MasterShellCommand(command=['rm', '-rf', '/tmp/incoming/%s_%s_%s/*' % (distro,distroversion,arch),
               ],
            ),
        ])
    

    # Now that we have all the steps in a factory, we can hand the factory back
    # to the Builder:
    return f
    # --- END OF make_factory()


def component_picker(components, distro):
    """
        Not all components are supported in all configurations, by all distributions. 
        So, we need a method to filter which component supports which distro. 
    """
    r = []
    for i in components:
        if distro in i[1]:
            r.append(i[0])
    return r

# A special builder that does postprocessing stuff
# (runs reprepro and syncs to bob.openpanel.com)
c['builders'].append(
    BuilderConfig(name="PostProcess",
    slavenames='postprocess-slave',  # <-- required parameter, even if no slave buildsteps.
    factory=PostProcess("debian")))

c['builders'].append(
    BuilderConfig(name="A-TestBuilder",
    slavenames='postprocess-slave',  # <-- required parameter, even if no slave buildsteps.
    factory=TestFactory("debian")))


'''
# Loop through all our different supported distros and versions and create
# builders for them:
for dist in distrodict:
    components = []
    # Assign slaves and a list of components based on distro:
    if dist == "debian":
        slavenames = ['debian6-amd64']
        components = component_picker(all_components, "deb")
    if dist == "ubuntu":
        slavenames = ['debian6-amd64']
        components = component_picker(all_components, "deb")
    if dist == "centos":
        slavenames = ['centos5-slave']
        components = component_picker(all_components, "rpm")

    # Differentiate the builders on version and architecture:
    for version in distrodict[dist]['version']:
        for arch in distrodict[dist]['architectures']:
                name = "%s_%s_%s" % (dist , version , arch)

                c['builders'].append(
                    BuilderConfig(name=name,
                    slavenames=slavenames,
                    factory=make_distro_factory(dist, version, arch, 'tip'))) 

'''

for dist in distrodict:
    components = []
    # Assign slaves and a list of components based on distro:
    if dist == "debian":
        slavenames = ['debian6-amd64']
        components = component_picker(all_components, "deb")
    if dist == "ubuntu":
        slavenames = ['debian6-amd64']
        components = component_picker(all_components, "deb")
    if dist == "centos":
        slavenames = ['centos5-slave']
        components = component_picker(all_components, "rpm")

    # Differentiate the builders on component, distro, distro version and architecture:
    for component in components:
        for version in distrodict[dist]['version']:
            for arch in distrodict[dist]['architectures']:
                    name = "%s_%s_%s_%s" % (component, dist , version , arch)
                    c['builders'].append(
                        BuilderConfig(name=name,
                        slavenames=slavenames,
                        factory=make_component_factory(component, dist, version, arch, 'tip'))) 


'''
# Generate builders per-component:
for component in all_components:
    if 'rpm' in  component[1] or 'deb' in component[1]:
        for dist in distrodict:
            components = []
            # Assign slaves and a list of components based on distro:
            if dist == "debian":
                slavenames = ['debian6-amd64']
                components = component_picker(all_components, "deb")
            if dist == "ubuntu":
                slavenames = ['debian6-amd64']
                components = component_picker(all_components, "deb")
            if dist == "centos":
                slavenames = ['centos5-slave']
                components = component_picker(all_components, "rpm")

            # Differentiate the builders on version and architecture:
            for version in distrodict[dist]['version']:
                for arch in distrodict[dist]['architectures']:
                        name = "%s_%s_%s_%s" % (component[0], dist , version , arch)

                        c['builders'].append(
                            BuilderConfig(name=name,
                            slavenames=slavenames,
                            factory=make_component_factory(component[0], dist, version, arch, 'tip'))) 
'''

# -- SCHEDULERS
# These define when a builder is called.
# Docs: http://buildbot.net/buildbot/docs/0.8.5/manual/cfg-schedulers.html

# Start out empty:
c['schedulers'] = []

# Since we have all builders defined, we can add schedules to them.
for builder in c['builders']:
    # This enables calling builders remotely:
    # (specifically 'change_filter' does that)
    name = builder.name
    c['schedulers'].append(
        SingleBranchScheduler(
            name = name,
            change_filter = ChangeFilter(project=name),
            treeStableTimer = 1, 
            builderNames = [name],
        ),)
    # Scheduled (time based) builds:
    c['schedulers'].append(
        timed.Nightly(
            name = 'nightly_%s' % name,
            builderNames=[name],
            hour=10,
            minute=00,
            branch="",
        ),
    ),




# Users that can do stuff:
users = [('bob', 'secret-pass'), ('jill', 'super-pass')]

# What can be done by those users:
authz = Authz(auth=BasicAuth(users),
    # change any of these to True to enable; see the manual for more
    # options
    gracefulShutdown = False,
    forceBuild = True,
    #PRODforceBuild = 'auth',
    forceAllBuilds = False,
    pingBuilder = False,
    stopBuild = True,
    stopAllBuilds = False,
    cancelPendingBuild = True,
)

####### STATUS TARGETS

# Official comments:
# ----
# 'status' is a list of Status Targets. The results of each build will be
# pushed to these targets. buildbot/status/*.py has a variety to choose from,
# including web pages, email senders, and IRC bots.
# ----
# Doc: http://buildbot.net/buildbot/docs/0.8.5/manual/cfg-statustargets.html

c['status'] = []

# -- This helps to enable buildbot to allow remotely triggered builds over
#    http:
c['status'].append(html.WebStatus(http_port=8010, authz=authz, 
        change_hook_dialects={
                'openpanel_hook': True,
            }
        ))

# On what port to listen for slaves:
from buildbot.changes import pb
c['changes'] = pb.PBChangeSource(port=9989)


####### PROJECT IDENTITY

# the 'title' string will appear at the top of this buildbot
# installation's html.WebStatus home page (linked to the
# 'titleURL') and is embedded in the title of the waterfall HTML page.

c['title'] = "OpenPanel"
c['titleURL'] = "http://openpanel.org"

# the 'buildbotURL' string should point to the location where the buildbot's
# internal web server (usually the html.WebStatus page) is visible. This
# typically uses the port number set in the Waterfall 'status' entry, but
# with an externally-visible host name which the buildbot cannot figure out
# without some help.

c['buildbotURL'] = "http://localhost:8010/"

####### DB URL

# This specifies what database buildbot uses to store change and scheduler
# state.  You can leave this at its default for all but the largest
# installations.
c['db_url'] = "sqlite:///state.sqlite"

